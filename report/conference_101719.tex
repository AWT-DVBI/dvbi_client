\documentclass[conference]{IEEEtran}
\IEEEoverridecommandlockouts
% The preceding line is only needed to identify funding in the first footnote. If that is unneeded, please comment it out.
\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}
\usepackage{url}
\usepackage{verbatim}
\usepackage{hyperref}
\usepackage[T1]{fontenc}
\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}
\begin{document}

\title{Developing a DVB-I Parser Library in Dart and GUI App in Flutter\\}

\author{\IEEEauthorblockN{1\textsuperscript{st} Luis Hebendanz}
\IEEEauthorblockA{\textit{M. Sc. Computer Science}\\
\textit{TU Berlin}\\
Berlin, Germany \\}
\and
\IEEEauthorblockN{2\textsuperscript{nd} Nicklas}
\IEEEauthorblockA{\textit{M. Sc. Information Systems Management} \\
\textit{TU Berlin}\\
Berlin, Germany \\}
\and
\IEEEauthorblockN{3\textsuperscript{rd} Balint}
\IEEEauthorblockA{\textit{M. Sc. Information Systems Management} \\
	\textit{TU Berlin}\\
	Berlin, Germany \\}
\and

}

\maketitle

\begin{abstract}
 In this project, we aimed to develop an efficient DVB-I parser library in Dart and a GUI app in Flutter to present TV services on Android devices.

We used the Dart programming language to write the DVB-I parser library and Google's cross-platform Flutter framework to develop the GUI app.

 However, we faced challenges in developing the GUI app in Flutter due to multiple bugs in the libraries we used and sparse documentation. Despite these challenges, we were able to develop a working app to present TV services on Android devices.

Our project demonstrates the feasibility of using Dart to write an efficient DVB-I parser library and Flutter to develop a GUI app that presents TV services on Android devices. However the challenges we faced in developing the GUI app highlight the importance of mature libraries and documentation to support developers in using these technologies. The lack of maturity in the Flutter ecosystem has compelled us to not recommend it for further projects.
\end{abstract}

\begin{IEEEkeywords}
IP-TV, DVB-I, Flutter, Dart, Cross Platform
\end{IEEEkeywords}

\section{Introduction}
In this project, we aimed to develop an efficient DVB-I parser library in Dart and a GUI app in Flutter to present TV services on Android devices. The DVB-I standard is a standards-based solution for delivering television via the internet and offers a discovery mechanism to signal and discover television services, using a set of REST APIs allowing clients to retrieve a list of services in an XML-based format. Our primary objective was to create a parser library that can efficiently handle the DVB-I service list registry and provide all the necessary information required to present the TV service in the client app. Additionally, we aimed to create an Android GUI app using Flutter that uses the DVB-I parser library to present the TV services to the user. 

The development of the DVB-I parser library involved reading the DVB-I standard and manually emulating REST requests as specified by the specification. We also familiarized ourselves with the Dart programming language and experimented with simple coding examples to gain proficiency with the language. Once we had a good understanding of the standard and the language, we designed and developed the DVB-I parser library using Dart, implementing the required REST APIs and XML parsing. 

The development of the Android GUI app using Flutter involved building an intuitive user interface to present the TV services to the user, as well as incorporating the DVB-I parser library to retrieve and display the information for each service. We faced challenges while developing the app, including multiple bugs in libraries used and sparse documentation, which affected the app's functionality and usability.

In this evaluation, we will assess the success of our project in achieving its goals and evaluate the performance and usability of the DVB-I parser library and Android GUI app developed. We will also discuss the challenges encountered during development and recommend future improvements to enhance the overall functionality and usability of the app.

\section{Scientific Background}

This section will provide an overview of the utilized technologies and their respective functionalities.


\section{Flutter Architecture Overview}

Flutter is a cross-platform framework for building mobile and desktop applications. Its architecture consists of four main layers: the Dart app layer, the framework layer, the engine layer, and the platform layer. Shown in figure \ref{fig:flutter_tech_stack}.

\begin{figure}[ht]
	\centerline{\includegraphics[width=\linewidth]{figures/app-anatomy}}
	\caption{Flutter architectural overview \cite{b1.1}}
	\label{fig:flutter_tech_stack}
\end{figure}

The Dart app layer is responsible for composing widgets into the desired UI and implementing business logic. It is owned by the app developer.

The framework layer provides a higher-level API for building UI apps, including widgets, hit-testing, gesture detection, accessibility, and text input. It composites the app's widget tree into a scene.

The engine layer is responsible for rasterizing composited scenes and provides low-level implementation of Flutter's core APIs, including graphics, text layout, and the Dart runtime. It exposes its functionality to the framework using the dart:ui API and integrates with a specific platform using the platform layer.

The platform layer ``is the native OS application that hosts all Flutter content and acts as the glue between the host operating system and Flutter``\cite{b1.1}. Flutter includes platform embedders for each of the target platforms, and you can also create a custom platform embedder.

In summary, Flutter's architecture provides a robust and efficient rendering pipeline, bypassing system UI widget libraries and using its own widget set and Skia 2D library \cite{b1.2} for rendering. This results in a high-performance, cross-platform framework with minimal abstractions and overhead.

\section{Integrating Flutter with other code}

Flutter and Dart provide several ways to integrate with other code written in different programming languages.

For mobile and desktop apps, Flutter provides platform channels, which are a mechanism for communicating between Dart code and the platform-specific code of the host app. This allows developers to call custom code written in languages like Kotlin, Swift, or C-based APIs, including those generated for code written in modern languages like Rust or Go. The platform channel mechanism serializes Dart types into a common message format, which is sent to the receiving code that then deserializes it into a programming language-specific object displayed in figure \ref{fig:platform-channels}. 

For C-based APIs, Dart provides a direct mechanism for binding to native code using the dart:ffi library, which can be considerably faster than platform channels since no serialization is required to pass data.

For web apps, the js package serves a similar purpose to dart:ffi for C-based APIs, allowing developers to bind to native code directly from Dart. Additionally, since web apps run in the browser, developers can also use Dart's interop capabilities to integrate with JavaScript libraries, either by importing JavaScript libraries into Dart or by calling Dart code from JavaScript.


\begin{figure}[ht]
	\centerline{\includegraphics[width=\linewidth]{figures/platform-channels}}
	\caption{Platform Channels Overview \cite{b1.1}}
	\label{fig:platform-channels}
\end{figure}

Overall, Flutter and Dart provide a variety of interoperability mechanisms that allow developers to integrate their code with other programming languages and platforms, providing flexibility and extensibility to their applications.

\section{Dart Language}

Dart is a class-based, object-oriented programming language with syntax that is similar to Java-style languages. It is optimized for client-side web and mobile app development, but can also be used for server-side programming. Some key concepts are:

\begin{enumerate}
	\item Everything in Dart is an object, and every object is an instance of a class.
	\item Dart has a garbage collector that automatically frees memory that is no longer in use. 
	\item Type annotations are optional in Dart because the language can infer types.
	\item If you enable null safety in Dart, variables cannot contain null values unless you explicitly make them nullable with a question mark (?).
	\item Dart does not have keywords for public, protected, and private access, but an identifier starting with an underscore (\_) is private to its library.
	\item Dart supports concurrent programming with async-await, Future, and Stream objects.
	\item A Future in Dart represents the result of an asynchronous operation and can be completed with a value or an error.
\end{enumerate}

\section{Dart Asynchronous Programming}
In Dart, async/await is a powerful mechanism that allows for writing asynchronous code in a synchronous style. With async/await, developers can write code that doesn't block the application's main event loop while waiting for I/O operations, network requests, or other time-consuming tasks to complete.

To use async/await in Dart, developers mark functions as "async" and use the "await" keyword to wait for the result of an asynchronous operation. When a function is marked as "async", it returns a Future object that can be used to obtain the result of the computation when it completes. The "await" keyword is used to wait for the Future to complete, and once it does, the result is returned as if it were a normal synchronous operation.

Async/await is particularly useful in situations where multiple asynchronous operations need to be performed in sequence, and the result of each operation is dependent on the completion of the previous one. 


\section{DVB-I Standard}

The DVB-I (Digital Video Broadcasting - Internet) protocol is a standard developed by the Digital Video Broadcasting (DVB) organization for delivering linear television services over the internet. It aims to provide simpler and more accessible options for viewing both linear and VOD streaming services on any internet-connected device.

At the core of the DVB-I protocol is the Service List Registry (SLR), which provides a REST API allowing clients to retrieve a list of services (ServiceList) in an XML-based format, including all information required to present the TV service in the client. The <Service> element of the ServiceList XML document holds metadata about a specific TV channel, such as the channel name, the channel logo URL, and the DASH MPD stream URL. The <ContentGuideSource> element, which can be referenced by multiple <Service> tags, provides information about the ProgramInfo and ScheduleInfo endpoints, which can be queried to retrieve more detailed information about the TV shows airing on the channel.

To retrieve scheduling information about the TV shows airing on the channel, clients can send a GET HTTP request to the ScheduleInfo endpoint, which should include the service element ID (sid), the start unix time, and the end unix time of the time period for which scheduling data is desired. The response to this request is a new XML document containing multiple <ProgramInformation> tags, each of which provides important details about the TV shows airing on the channel, such as the main title, duration, and start time.

Clients can also query the ProgramInfo endpoint to retrieve additional metadata about the TV shows airing on the channel, including the minimum age requirement, genre, and a longer description. This information can be useful for clients in presenting a more detailed schedule of TV shows to the user.

Overall, the DVB-I protocol provides a standard mechanism for delivering linear television services over the internet, with the aim of providing a seamless viewing experience across multiple devices without any limitations. The use of REST APIs and XML-based formats for delivering information about TV channels and shows enables clients to easily retrieve the information they need to present a comprehensive TV service to the user.


\section{Development Setup}

For Linux the Nix package manager and its accompanying development environment has been found to provide an efficient and organized approach to setting up a development environment. This method involves installing the Nix package manager as outlined in the project's README, followed by executing the \texttt{nix develop} command to obtain all necessary dependencies and enter into a virtual environment akin to that of Python. The configuration of the development environment is defined in the \texttt{flake.nix} file, which enables developers to specify the required software and tools, including their respective versions. Furthermore, this approach includes preconfigured tools such as VSCodium with preinstalled extensions, the Android SDK, and the Flutter compiler, resulting in a streamlined and time-efficient setup process.

In summary, the utilization of Nix and its development environment provides an effective strategy for minimizing the complexity of setting up a development environment, ensuring reproducibility, and creating a dependable development environment.

For Windows Flutter... TODO

\begin{comment}

\subsection{DVB-I Standard}

%DVB-I standard rough overview of the structure

%What is DVBI


The DVB-I (DVB-Internet) standard is a specification developed by the Digital Video Broadcasting (DVB) organization for delivering linear television services over the internet.The standard defines the mechanisms to be used to find sets of linear television services delivered through broadband or broadcast mechanisms as well as methods to retrieve electronic programme data for those services.[ref to document]

The core of the specification is the Service List Registry (SLR) which provides a set of REST APIs allowing clients (TVs, Mobile, Browser) to retrieve a list of services (ServiceList) in an XML-based format including all information required to present the TV service in the client. The DVB-I standard, published by ETSI, expands upon the existing DVB Broadcast-based delivery methods, such as Terrestrial, Satellite, and Cable, to provide simpler and more accessible options for viewing both Linear and VOD Streaming services on any internet-connected device. With this open standard, users can enjoy a seamless viewing experience across multiple devices without any limitations.

\end{comment}


\begin{comment}

\subsection{Flutter}

What is Flutter. How does it work? Why we chose it?

Flutter is an open-source mobile app development framework developed by Google that allows developers to create high-performance, cross-platform mobile applications for iOS, Android, and other platforms from a single codebase.

Flutter uses a programming language called Dart, which is also developed by Google, and provides a rich set of pre-built UI widgets and tools that allow developers to create visually appealing and interactive mobile applications. The framework uses a reactive programming model, which means that changes in the app's state are automatically reflected in the UI, making it easy to build dynamic user interfaces.

One of the key benefits of Flutter is its hot-reload feature, which allows developers to quickly see the changes they make to the code in real-time on the app, without having to rebuild the entire application. This significantly speeds up the development process and makes it easier for developers to experiment with different UI designs and functionality.

Flutter is also known for its fast development speed and ease of use, making it an ideal choice for startups and businesses that need to quickly develop and deploy high-quality mobile applications.

In addition to mobile app development, Flutter can also be used for building desktop and web applications, thanks to its platform-independent nature. Overall, Flutter is a powerful and flexible mobile app development framework that is rapidly gaining popularity in the developer community.

\end{comment}



\section{Implementation}



Our implementation is split into four big parts: the development setup \ref{dev_set}, a general overview of the architcture  \ref{arch}, the dvb-i parser libary, which contains all the xml parsings and http requests \ref{dvbi_parser} and finally the user interface which the client interacts with. \ref{gui}. The code for this implementation can be found on \emph{github}\footnote{\url{https://github.com/AWT-DVBI/dvbi_client}}.


\subsection{Development Setup}\label{dev_set}

Development Setup:
Using Nix for a development environment
TODO: Setup for Windows
describe important libs that were used


\subsection{Architecture}\label{arch}

\subsubsection{General Overview}
General Architecture:
walkthrough of how a user interacts with client and how parser requests more info
graphic of architecture


\subsection{Dvb-I Parser}\label{dvbi_parser}

libraries used
XML to Dart object mapping
Features:
Lazy loading. Only request data you need. Request more on obj access
Async http request for parallel fetching
XML to JSON parsing  

\subsection{Gui Application}\label{gui}

libraries used(?)
layout of GUI/Screenshots
Content Guide Page
features: breaks everything 
Channel Browsing
features: subtitles, volume control, next/prev channel, show channel logo and name

\section{Challenges}

Dart Streams, Dart async
idea: reduce loading times by asynchr loading channels. 
State Management in Flutter: 
Unaccounted for Dart language features in Riverpod
Riverpod: Providers + Dart streams = StreamProviders
out-of-the-box state management using State widgets
	
DVB-I Server wrong response data with official endpoints ( use of different staging Endpoints for correct data)
start and end time 
flexibility in standard leads to many edge cases 
Bugs in libraries: videoplayer, chewie
o(n2) performance issue due to the structure of the given xml tree and our used xml lib

\section{Evaluation}

scalability
include screenshots cross platform framework flutter ....does it work on android and apples ios?
only android in combination with exoplayer as mpeg dash is not supported by hls and the current flutter videoplayer libs

\section{Conclusion and Future Work}

subtitles, channel info button



\subsection{Figures and Tables}
\paragraph{Positioning Figures and Tables} Place figures and tables at the top and 
bottom of columns. Avoid placing them in the middle of columns. Large 
figures and tables may span across both columns. Figure captions should be 
below the figures; table heads should appear above the tables. Insert 
figures and tables after they are cited in the text. Use the abbreviation 
``Fig.~\ref{fig}'', even at the beginning of a sentence.

\begin{table}[htbp]
\caption{Table Type Styles}
\begin{center}
\begin{tabular}{|c|c|c|c|}
\hline
\textbf{Table}&\multicolumn{3}{|c|}{\textbf{Table Column Head}} \\
\cline{2-4} 
\textbf{Head} & \textbf{\textit{Table column subhead}}& \textbf{\textit{Subhead}}& \textbf{\textit{Subhead}} \\
\hline
copy& More table copy$^{\mathrm{a}}$& &  \\
\hline
\multicolumn{4}{l}{$^{\mathrm{a}}$Sample of a Table footnote.}
\end{tabular}
\label{tab1}
\end{center}
\end{table}

\begin{figure}[htbp]
\centerline{\includegraphics{fig1.png}}
\caption{Example of a figure caption.}
\label{fig}
\end{figure}

Figure Labels: Use 8 point Times New Roman for Figure labels. Use words 
rather than symbols or abbreviations when writing Figure axis labels to 
avoid confusing the reader. As an example, write the quantity 
``Magnetization'', or ``Magnetization, M'', not just ``M''. If including 
units in the label, present them within parentheses. Do not label axes only 
with units. In the example, write ``Magnetization (A/m)'' or ``Magnetization 
\{A[m(1)]\}'', not just ``A/m''. Do not label axes with a ratio of 
quantities and units. For example, write ``Temperature (K)'', not 
``Temperature/K''.

\section*{Acknowledgment}

The preferred spelling of the word ``acknowledgment'' in America is without 
an ``e'' after the ``g''. Avoid the stilted expression ``one of us (R. B. 
G.) thanks $\ldots$''. Instead, try ``R. B. G. thanks$\ldots$''. Put sponsor 
acknowledgments in the unnumbered footnote on the first page.

\section*{References}

Please number citations consecutively within brackets \cite{b1}. The 
sentence punctuation follows the bracket \cite{b2}. Refer simply to the reference 
number, as in \cite{b3}---do not use ``Ref. \cite{b3}'' or ``reference \cite{b3}'' except at 
the beginning of a sentence: ``Reference \cite{b3} was the first $\ldots$''

Number footnotes separately in superscripts. Place the actual footnote at 
the bottom of the column in which it was cited. Do not put footnotes in the 
abstract or reference list. Use letters for table footnotes.

Unless there are six authors or more give all authors' names; do not use 
``et al.''. Papers that have not been published, even if they have been 
submitted for publication, should be cited as ``unpublished'' \cite{b4}. Papers 
that have been accepted for publication should be cited as ``in press'' \cite{b5}. 
Capitalize only the first word in a paper title, except for proper nouns and 
element symbols.

For papers published in translation journals, please give the English 
citation first, followed by the original foreign-language citation \cite{b6}.

\begin{thebibliography}{00}
\bibitem{b1.1} Flutter, ``Flutter architectural overview``, [Online] \url{https://docs.flutter.dev/resources/architectural-overview}
	
\bibitem{b1.2} Skia 2D, ``Skia 2D Rendering Library``, [Online]
\url{https://skia.org/}
	
%=============================0%
\bibitem{b1} G. Eason, B. Noble, and I. N. Sneddon, ``On certain integrals of Lipschitz-Hankel type involving products of Bessel functions,'' Phil. Trans. Roy. Soc. London, vol. A247, pp. 529--551, April 1955.
\bibitem{b2} J. Clerk Maxwell, A Treatise on Electricity and Magnetism, 3rd ed., vol. 2. Oxford: Clarendon, 1892, pp.68--73.
\bibitem{b3} I. S. Jacobs and C. P. Bean, ``Fine particles, thin films and exchange anisotropy,'' in Magnetism, vol. III, G. T. Rado and H. Suhl, Eds. New York: Academic, 1963, pp. 271--350.
\bibitem{b4} K. Elissa, ``Title of paper if known,'' unpublished.
\bibitem{b5} R. Nicole, ``Title of paper with only first word capitalized,'' J. Name Stand. Abbrev., in press.
\bibitem{b6} Y. Yorozu, M. Hirano, K. Oka, and Y. Tagawa, ``Electron spectroscopy studies on magneto-optical media and plastic substrate interface,'' IEEE Transl. J. Magn. Japan, vol. 2, pp. 740--741, August 1987 [Digests 9th Annual Conf. Magnetics Japan, p. 301, 1982].
\bibitem{b7} M. Young, The Technical Writer's Handbook. Mill Valley, CA: University Science, 1989.
\end{thebibliography}
\vspace{12pt}
\color{red}
IEEE conference templates contain guidance text for composing and formatting conference papers. Please ensure that all template text is removed from your conference paper prior to submission to the conference. Failure to remove the template text from your paper may result in your paper not being published.

\end{document}
